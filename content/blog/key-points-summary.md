---
path: Key points summary
date: 2020-07-12T18:56:34.517Z
title: key points summary
description: collection of all keypoints
---
### **Socio-technical systems**

• Socio-technical systems include computer hardware, software and people and are designed to meet some business goal.

• Emergent properties are properties that are characteristic of the system as a whole and not its component parts.

• The systems engineering process includes specification, design, development, integration and testing. System integration is particularly critical.

• Human and organizational factors have a significant effect on the operation of socio-technical systems.

* There are complex interactions between the processes of system procurement, development and operation.
* A legacy system is an old system that continues to provide essential services.

  • Legacy systems include business processes, application software, support software and system hardware.

### Software Processes

* Software processes are the activities involved in producing and evolving a software system.
* • Software process models are abstract representations of these processes.
* • General activities are specification, design and implementation, validation and evolution.
* • Generic process models describe the organisation of software processes. Examples include the waterfall model, evolutionary development and component-based software engineering.
* • Iterative process models describe the software process as a cycle of activities.
* • Requirements engineering is the process of developing a software specification.
* • Design and implementation processes transform the specification to an executable program.
* • Validation involves checking that the system meets to its specification and user needs.
* • Evolution is concerned with modifying the system after it is in use.
* • The Rational Unified Process is a generic process model that separates activities from phases.
* • CASE technology supports software process activities.

### Requirements-Engineering

◇ Requirements for a software system set out what the system should do and define constraints on its operation and implementation.

* ◇ Functional requirements are statements of the services that the system must provide or are descriptions of how some computations must be carried out.
* ◇ Non-functional requirements often constrain the system being developed and the development process being used.
* ◇ They often relate to the emergent properties of the system and therefore apply to the system as a whole.
* ◇ The requirements engineering process is an iterative process that includes requirements elicitation, specification and validation.
* ◇ Requirements elicitation is an iterative process that can be represented as a spiral of activities – requirements discovery, requirements classification and organization, requirements negotiation and requirements documentation.
* ◇ You can use a range of techniques for requirements elicitation including interviews and ethnography. User stories and scenarios may be used to facilitate discussions.
* ◇ Requirements specification is the process of formally documenting the user and system requirements and creating a software requirements document.
* ◇ The software requirements document is an agreed statement of the system requirements. It should be organized so that both system customers and software developers can use it.
* ◇ Requirements validation is the process of checking the requirements for validity, consistency, completeness, realism and verifiability.
* ◇ Business, organizational and technical changes inevitably lead to changes to the requirements for a software system. Requirements management is the process of managing and controlling these changes.

### Missing Requirements Slides

Key points

* ◇ Requirements for a software system set out what the system should do and define constraints on its operation and implementation.
* ◇ Functional requirements are statements of the services that the system must provide or are descriptions of how some computations must be carried out.
* ◇ Non-functional requirements often constrain the system being developed and the development process being used.
* ◇ They often relate to the emergent properties of the system and therefore apply to the system as a whole.
* ◇ The requirements engineering process is an iterative process that includes requirements elicitation, specification and validation.
* ◇ Requirements elicitation is an iterative process that can be represented as a spiral of activities – requirements discovery, requirements classification and organization, requirements negotiation and requirements documentation.
* ◇ You can use a range of techniques for requirements elicitation including interviews and ethnography. User stories and scenarios may be used to facilitate discussions.
* ◇ Requirements specification is the process of formally documenting the user and system requirements and creating a software requirements document.
* ◇ The software requirements document is an agreed statement of the system requirements. It should be organized so that both system customers and software developers can use it.

◇ Requirements validation is the process of checking the requirements for validity, consistency, completeness, realism and verifiability.

* ◇ Business, organizational and technical changes inevitably lead to changes to the requirements for a software system. Requirements management is the process of managing and controlling these changes.

### System Models

* ◇ Behavioral models are used to describe the dynamic behavior of an executing system. This behavior can be modeled from the perspective of the data processed by the system, or by the events that stimulate responses from a system.
* ◇ Activity diagrams may be used to model the processing of data, where each activity represents one process step.
* ◇ State diagrams are used to model a system’s behavior in response to internal or external events.
* ◇ Model-driven engineering is an approach to software development in which a system is represented as a set of models that can be automatically transformed to executable code.

### Architecture Design

* ◇ A software architecture is a description of how a software system is organized.
* ◇ Architectural design decisions include decisions on the type of application, the distribution of the system, the architectural styles to be used.
* ◇ Architectures may be documented from several different perspectives or views such as a conceptual view, a logical view, a process view, and a development view.
* ◇ Architectural patterns are a means of reusing knowledge about generic system architectures. They describe the architecture, explain when it may be used and describe its advantages and disadvantages.
* ◇ Models of application systems architectures help us understand and compare applications, validate application system designs and assess large-scale components for reuse.
* ◇ Transaction processing systems are interactive systems that allow information in a database to be remotely accessed and modified by a number of users.
* ◇ Language processing systems are used to translate texts from one language into another and to carry out the instructions specified in the input language. They include a translator and an abstract machine that executes the generated language.

### Testing

* ◇ When testing software,you should try to‘ break’the software by using experience and guidelines to choose types of test case that have been effective in discovering defects in other systems.
* ◇ Wherever possible, you should write automated tests.The tests are embedded in a program that can be run every time a change is made to a system.
* ◇ Test first development is an approach to development where tests are written before the code to be tested.
* ◇ Scenariotestinginvolvesinventingatypicalusagescenarioand using this to derive test cases.
* ◇ Acceptancetestingisausertestingprocesswheretheaimisto decide if the software is good enough to be deployed and used in its operational environment.

### Evolution

* ◇ Software development and evolution can be thought of as an integrated, iterative process that can be represented using a spiral model.
* ◇ For custom systems, the costs of software maintenance usually exceed the software development costs.
* ◇ The process of software evolution is driven by requests for changes and includes change impact analysis, release planning and change implementation.
* ◇ Legacy systems are older software systems, developed using obsolete software and hardware technologies, that remain useful for a business.
* ◇ It is often cheaper and less risky to maintain a legacy system than to develop a replacement system using modern technology.
* ◇ The business value of a legacy system and the quality of the application should be assessed to help decide if a system should be replaced, transformed or maintained.
* ◇ There are 3 types of software maintenance, namely bug fixing, modifying software to work in a new environment, and implementing new or changed requirements.
* ◇ Software re-engineering is concerned with re-structuring and re-documenting software to make it easier to understand and change.
* ◇ Refactoring, making program changes that preserve functionality, is a form of preventative maintenance.

### Software reuse

* ◇ There are many different ways to reuse software.These range from the reuse of classes and methods in libraries to the reuse of complete application systems.
* ◇ The advantages of software reuse are lower costs,faster software development and lower risks. System dependability is increased. Specialists can be used more effectively by concentrating their expertise on the design of reusable components.
* ◇ Application frameworks are collections of concrete and abstract objects that are designed for reuse through specialization and the addition of new objects. They usually incorporate good design practice through design patterns.
* ◇ Software productlines are related applications that are developed from one or more base applications. A generic system is adapted and specialized to meet specific requirements for functionality, target platform or operational configuration.
* ◇ Application system reuse is concerned with the reuse of large-scale, off-the-shelf systems. These provide a lot of functionality and their reuse can radically reduce costs and development time. Systems may be developed by configuring a single, generic application system or by integrating two or more application systems.
* ◇ Potential problems with application system reuse include lack of control over functionality and performance, lack of control over system evolution, the need for support from external vendors and difficulties in ensuring that systems can inter-operate.

### Component-based software engineering

* ◇ CBSE is a reuse-based approach to defining and implementing loosely coupled components into systems.
* ◇ A component is a software unit whose functionality and dependencies are completely defined by its interfaces.
* ◇ Components may be implemented as executable elements included in a system or as external services.
* ◇ A component model defines a set of standards that component providers and composers should follow.
* ◇ The key CBSE processes are CBSE for reuse and CBSE with reuse.
* ◇ During the CBSE process, the processes of requirements engineering and system design are interleaved.
* ◇ Component composition is the process of ‘wiring’ components together to create a system.
* ◇ When composing reusable components, you normally have to write adaptors to reconcile different component interfaces.
* ◇ When choosing compositions, you have to consider required functionality, non-functional requirements and system evolution.

### Project management

* ◇ Good projectmanagementisessentialifsoftwareengineering projects are to be developed on schedule and within budget.
* ◇ Softwaremanagementisdistinctfromotherengineering management. Software is intangible. Projects may be novel or innovative with no body of experience to guide their management. Software processes are not as mature as traditional engineering processes.
* ◇ Riskmanagementinvolvesidentifyingandassessingprojectrisksto establish the probability that they will occur and the consequences for the project if that risk does arise. You should make plans to avoid, manage or deal with likely risks if or when they arise.
* ◇ Peoplemanagementinvolveschoosingtherightpeopletoworkona project and organizing the team and its working environment.
* ◇ Peoplearemotivatedbyinteractionwithotherpeople,therecognition of management and their peers, and by being given opportunities for personal development.
* ◇ Softwaredevelopmentgroupsshouldbefairlysmallandcohesive. The key factors that influence the effectiveness of a group are the people in that group, the way that it is organized and the communication between group members.
* ◇ Communicationswithinagroupareinfluencedbyfactorssuchasthe status of group members, the size of the group, the gender composition of the group, personalities and available communication channels.

### Project planning

* ◇ Thepricechargedforasystemdoesnotjustdependonitsestimated development costs and the profit required by the development company. Organizational factors may mean that the price is increased to compensate for increased risk or decreased to gain competitive advantage.
* ◇ Softwareisoftenpricedtogainacontractandthefunctionalityofthe system is then adjusted to meet the estimated price.
* ◇ Plan-drivendevelopmentisorganizedaroundacompleteproject plan that defines the project activities, the planned effort, the activity schedule and who is responsible for each activity.
* ◇ Projectschedulinginvolvesthecreationofvariousgraphical representations of part of the project plan. Bar charts, which show the activity duration and staffing timelines, are the most commonly used schedule representations.
* ◇ Aprojectmilestoneisapredictableoutcomeofanactivityorsetof activities. At each milestone, a formal report of progress should be presented to management. A deliverable is a work product that is delivered to the project customer.
* ◇ Theagileplanninggameinvolvesthewholeteaminprojectplanning. The plan is developed incrementally and, if problems arise, it is adjusted so that software functionality is reduced instead of delaying the delivery of an increment.+

Estimationtechniquesforsoftwaremaybeexperience-based,where managers judge the effort required, or algorithmic, where the effort required is computed from other estimated project parameters.

TheCOCOMOIIcostingmodelisamaturealgorithmiccostmodel that takes project, product, hardware and personnel attributes into account when formulating a cost estimate.



keypoints are written by professor weber wulff